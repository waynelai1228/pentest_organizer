import json
import sqlite3
import uuid
from model.vulnerability import Vulnerability

# TODO: make all functions return vulnerability object instead of raw results

class VulnerabilityDAO:
    def __init__(self, db_name: str):
        # connect to database
        self.con = sqlite3.connect(db_name)
        self.cur = self.con.cursor()

        self.cur.row_factory = lambda cursor, row: row[0]
        self.construct_vuln_uuids_set()

    def construct_vuln_uuids_set(self):
        # statement to get the list of uuids
        vuln_uuids_select_statement = "SELECT uuid FROM vulnerabilities"
        res = self.cur.execute(vuln_uuids_select_statement)
        self.valid_vuln_uuids = set(res.fetchall())

    # return all vulnerabilities stored in the database
    def get_all(self):
        self.cur.row_factory = None 
        # statement to get all fields of all entries from vulnerabilities table
        get_vuln_statement = "SELECT * FROM vulnerabilities"

        try:
            # execute the statement
            res = self.cur.execute(get_vuln_statement)
            # get the result
            vulns_list = res.fetchall()
            # atomic operation
            self.con.commit()
    
            vulns_obj_list = []
    
            for vuln in vulns_list:
                vulns_obj_list.append(Vulnerability(vuln[0], vuln[1], vuln[2], vuln[3]))
    
            return vulns_obj_list
        except:
            return None

    # get vulnerability by a specific uuid
    def get_vuln_by_id(self, uuid: str):
        self.cur.row_factory = None 
        # create a tuple to pass into the parameter
        data = (uuid,)
        # statement to query all fields of the vulnerability with specific uuid
        get_vuln_statement = "SELECT * FROM vulnerabilities WHERE uuid=?"

        try:
            # execute the statement
            res = self.cur.execute(get_vuln_statement, data)
            # obtain the result
            vuln = res.fetchall()
            # atomic operation
            self.con.commit()
    
            vuln_obj = Vulnerability(vuln[0], vuln[1], vuln[2], vuln[3])
    
            return vuln_obj
        except:
            return None

    # add vulnerability to database using vulnerability object
    def add_vuln(self, vuln: Vulnerability):
        data = (vuln.uuid, vuln.name, vuln.description, str(vuln.resources), str(vuln.categories))
        # statement to add vulnerability into table
        add_vuln_statement = "INSERT INTO vulnerabilities VALUES(?, ?, ?, ?, ?)"

        try:
            # execute the statement
            res = self.cur.execute(add_vuln_statement, data)
            # atomic operation
            self.con.commit()
    
            self.valid_vuln_uuids.add(vuln_uuid)
    
            return vuln_uuid
        except:
            return None

    # add vulnerability to database using raw data
    def add_vuln(self, name: str, description: str, resources, categories):
        vuln_uuid = str(uuid.uuid4())

        # construct data tuple for the parameters
        data = (vuln_uuid, name, description, str(resources), str(categories))
        # statement to add vulnerability into table
        add_vuln_statement = "INSERT INTO vulnerabilities VALUES(?, ?, ?, ?, ?)"

        try:
            # execute the statement
            res = self.cur.execute(add_vuln_statement, data)
            # atomic operation
            self.con.commit()
    
            self.valid_vuln_uuids.add(vuln_uuid)
    
            return vuln_uuid
        except:
            return None

    # remove vulnerability from database
    def remove_vuln_by_id(self, uuid: str) -> bool:
        self.cur.row_factory = None 
        # create a tuple to pass into the parameter
        data = (uuid,)
        # statement to delete all fields of the vulnerability with specific uuid
        delete_vuln_statement = "DELETE FROM vulnerabilities WHERE uuid=?"
        try:
            # execute the statement
            res = self.cur.execute(delete_vuln_statement, data)
            # obtain the result
            res.fetchall()
            # atomic operation
            self.con.commit()
    
            return True
        except:
            return False
